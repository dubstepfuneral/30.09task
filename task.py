# -*- coding: utf-8 -*-
"""task

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1g45IbRoRMmGoj-3QgrzzSNIMeqOk7Au1
"""

# Ниже приведена функция, работающая со списками, в ней есть баг. Исходя из описания функции,
# найдите в ней баг

def has_lucky_number(nums):
    """Возвращает, является ли данный список чисел счастливым. Счастливый список должен
    содержать по крайней мере одно число, кратное 7
    """
    ans = False
    """Variable for the result"""
    for num in nums:
        if num % 7 == 0:
            ans = True
    return ans

# Реализуйте функцию is_year_leap, которая принимает на вход год,
# и возвращает информацию о том, является ли год високосным

# https://ru.wikihow.com/%D0%B2%D1%8B%D1%81%D1%87%D0%B8%D1%82%D1%8B%D0%B2%D0%B0%D1%82%D1%8C-%D0%B2%D0%B8%D1%81%D0%BE%D0%BA%D0%BE%D1%81%D0%BD%D1%8B%D0%B5-%D0%B3%D0%BE%D0%B4%D1%8B

def is_year_leap(year):
    """если год високосный, то он делится на 4 и не делится на 100, но если он делится на 400, то он высокосный"""
    if year % 4 == 0 and (year % 100 != 0 or year % 400 == 0): 
        return True
    else:
        return False

# Написать функцию square, принимающую 1 аргумент — сторону квадрата,
# и возвращающую 3 значения (в виде кортежа): периметр квадрата,
# площадь квадрата и диагональ квадрата

def square_statistcis(square):
    result = (square*4, square**2, square*(2**0.5))
    return result

#Пользователь делает вклад в размере a рублей сроком на years лет под m% годовых (каждый год размер его вклада
# увеличивается на m%. Эти деньги прибавляются к сумме вклада, и на них в следующем году тоже будут проценты).
#Написать функцию count_money, принимающая аргументы initial_money_amount,
# percent и years, и возвращающую сумму, которая будет на счету пользователя к концу переиода

def count_money(initial_money_amount, percent, years):
    endMoney = initial_money_amount # the money amount we'll end up with after the am-t of years, starting with the initial amount
    for i in range(years):
        endMoney = endMoney + endMoney*(percent*0.01)
    return int(endMoney)

# Предлагается реализовать функцию, сравнивающую каждый элемент списка с заданным числом.

def elementwise_greater_than(L, thresh): # thresh = threshold i guess
    """Возвращает список той же длины, что и L, где значение в индексе i равно
    True, если L[i] больше порогового значения, и False в противном случае """
    result = [] # variable for the result
    for i in L:
        if i > thresh:
            result.append(True)
        else:
            result.append(False)
    return result

assert(elementwise_greater_than([1, 2, 3, 4], 2) == [False, False, True, True])

def is_valid_zip(zip_code):
    """Проверяет индес на валидность. Будем считать, что почтовый индекс валиден, если он состоит из 6 цифр"""
    
    """first check, for all integers"""
    allIntegers = zip_code.isnumeric()
    if allIntegers == False:
        return False
    """second check, for length"""
    if len(zip_code) == 6:
        return True
    else:
        return False

assert(is_valid_zip('123456') == True)
assert(is_valid_zip('12345a') == False)

# Исследователь собрал тысячи новостных статей. Ему требуется отобрать из этих статей лишь те,
# которые содержат определенное слово. Закончите функцию ниже.

# - Документы содержащие искомое слово внутри другого не должны учитываться (например слово
# "москит", если мы ищем документы со словом "кит")
# - Слова написанные буквами в разном регистре это одни и те же слова (например "кот" то же, что и
# "Кот")
# - Если за словом идет знак препинания, это не должно влиять на поиск (например, если в тексте
# есть "башмак, который порван", то по слову "башмак" мы должны выдавать этот текст)

def word_search(doc_list, keyword):
    """
    Принимает список документов doc_list (каждый документ представляет собой строку) и ключевое слово.
    Возвращает список значений индекса в исходный список для всех документов, содержащих ключевое слово. """
    


doc_list = ["Москит укусил туриста", "Кит, в Тихом океане", "Кот-бегемот"]
print(word_search(doc_list, 'кит'))

# EXTRA TASK 1
# Рассчитать ежемесячные выплаты (m) и суммарную выплату (s) по кредиту.
# О кредите известно, что он составляет n рублей, берется на y лет, под p процентов
# Месячные выплаты находятся по формуле:
# m = (n * p * (1 + p)y) / (12 * ((1 + p)y – 1)), где p выражается в долях единицы, а не процентах.

#Суммарная выплата представляет собой выплаты за все месяцы каждого года:
# s = (m * 12) * y

# EXTRA TASK 2
# Написать функцию XOR_cipher, принимающая 2 аргумента: строку, которую нужно зашифровать,
# и ключ шифрования, которая возвращает строку, зашифрованную путем применения функции XOR (^)
# над символами строки с ключом. Написать также функцию XOR_uncipher, которая по зашифрованной
# строке и ключу восстанавливает исходную строку.

# EXTRA TASK 3
# Написать функцию date, принимающую 3 аргумента — день, месяц и год. Вернуть True,
# если такая дата есть в нашем календаре, и False иначе (воспользуйтесь функцией is_leap_year)